services:
  api:
    container_name: api
    # Use IMAGE_NAME and IMAGE_TAG to pull from a registry (GHCR).
    # IMAGE_NAME must be set in server .env (no default).
    image: ${IMAGE_NAME}:${IMAGE_TAG:-latest}
    ports:
      - "3000:3000"
    environment:
      - TMDB_API_KEY
      - STREAM_SIGNING_SECRET
      - STREAM_PROXY_BASE
      - FORWARD_HEADERS
      - REDIS_URL=redis://redis:6379
      - TMDB_CACHE_SECONDS=2592000
    volumes:
      - ./data:/app/data
    depends_on:
      - redis
    # Wait for Redis using REDIS_URL env (supports redis://user:pass@host:port/path)
    # Parse host/port from REDIS_URL and wait for TCP availability, then start the app.
    command:
      - /bin/bash
      - -lc
      - |
        REDIS_URL="$${REDIS_URL:-redis://redis:6379}"
        # strip scheme
        u=$${REDIS_URL#*://}
        # drop user:pass@ if present
        if [[ "$$u" == *"@"* ]]; then u=$${u#*@}; fi
        # remove path
        hostport=$${u%%/*}
        host=$${hostport%%:*}
        port=$${hostport#*:}
        if [ "$$port" = "$$host" ] || [ -z "$$port" ]; then port=6379; fi
        echo "Waiting for redis at $$host:$$port (from $$REDIS_URL)"
        # Use a non-blocking test to open TCP socket and exit immediately
        until bash -c "echo > /dev/tcp/$$host/$$port" >/dev/null 2>&1; do sleep 1; done
        echo "Redis reachable at $$host:$$port, starting app"
        exec npm start
    restart: unless-stopped
    networks:
      - livoplayer_net

  redis:
    image: redis:7-alpine
    container_name: redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - livoplayer_net

networks:
  livoplayer_net:
    external: true

volumes:
  redis_data:
    driver: local
